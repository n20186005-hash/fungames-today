<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Pulse: Cyberpunk Reflex Challenge</title>
    <style>
        :root {
            --neon-green: #39ff14;
            --neon-red: #ff0055;
            --neon-blue: #00ffff;
            --neon-yellow: #ffff00;
            --bg-color: #050505;
            --ui-font: 'Courier New', Courier, monospace;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            overflow: hidden;
            font-family: var(--ui-font);
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }

        /* Common Text Styles */
        .neon-text {
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .title {
            color: var(--neon-green);
            font-size: 4rem;
            text-shadow: 0 0 20px var(--neon-green), 0 0 40px var(--neon-green);
            margin-bottom: 10px;
            letter-spacing: 5px;
            font-weight: 900;
            text-transform: uppercase;
            animation: pulseTitle 2s infinite alternate;
        }

        @keyframes pulseTitle {
            from { text-shadow: 0 0 20px var(--neon-green); }
            to { text-shadow: 0 0 40px var(--neon-green), 0 0 10px #fff; }
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 30px;
            line-height: 1.5;
            max-width: 600px;
            padding: 0 20px;
        }

        /* Interactive Elements */
        .btn-group {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            pointer-events: auto;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.6);
            color: var(--neon-green);
            border: 2px solid var(--neon-green);
            padding: 12px 30px;
            font-size: 1.2rem;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 10px var(--neon-green), inset 0 0 5px var(--neon-green);
            transition: all 0.2s ease;
            font-family: inherit;
            font-weight: bold;
            min-width: 150px;
        }

        .btn:hover, .btn.active {
            background: var(--neon-green);
            color: #000;
            box-shadow: 0 0 30px var(--neon-green);
        }

        .btn-secondary {
            color: var(--neon-blue);
            border-color: var(--neon-blue);
            box-shadow: 0 0 10px var(--neon-blue), inset 0 0 5px var(--neon-blue);
        }
        .btn-secondary:hover, .btn-secondary.active {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 30px var(--neon-blue);
        }

        /* Top Bar UI */
        #top-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 20;
        }

        .hud-element {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .score-box {
            text-align: right;
        }

        .score-val {
            font-size: 2.5rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px #fff;
        }

        .label {
            font-size: 0.8rem;
            color: var(--neon-blue);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .icon-btn {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.3);
            color: #fff;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.2s;
            margin-bottom: 10px;
        }
        .icon-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: #fff;
        }

        /* Dropdown */
        select.lang-select {
            background: #000;
            color: #fff;
            border: 1px solid #555;
            padding: 5px;
            font-family: inherit;
            cursor: pointer;
            pointer-events: auto;
        }

        /* Overlay Screens */
        .screen {
            background: rgba(5, 5, 5, 0.85);
            backdrop-filter: blur(5px);
            padding: 40px;
            border: 1px solid #333;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            transform: scale(1);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .hidden {
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }
        
        /* Mobile adjustments */
        @media (max-width: 600px) {
            .title { font-size: 2.5rem; }
            .btn { padding: 10px 20px; font-size: 1rem; min-width: 120px; }
            .score-val { font-size: 1.8rem; }
            #top-bar { padding: 15px; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <!-- Top HUD -->
    <div id="top-bar">
        <div class="hud-element">
            <select id="lang-select" class="lang-select" onchange="changeLanguage(this.value)">
                <option value="en">English</option>
                <option value="zh">‰∏≠Êñá</option>
                <option value="ja">Êó•Êú¨Ë™û</option>
                <option value="es">Espa√±ol</option>
                <option value="fr">Fran√ßais</option>
            </select>
            <button id="pause-btn" class="icon-btn" onclick="togglePause()">‚è∏</button>
            <button id="mute-btn" class="icon-btn" onclick="toggleMute()">üîä</button>
        </div>
        <div class="hud-element score-box">
            <div>
                <span class="label" data-i18n="score">SCORE</span>
                <div id="score-display" class="score-val">0</div>
            </div>
            <div style="margin-top: 5px; opacity: 0.7;">
                <span class="label" data-i18n="best">BEST</span>
                <span id="highscore-display" style="color:var(--neon-yellow)">0</span>
            </div>
        </div>
    </div>

    <!-- UI Layer -->
    <div id="ui-layer">
        
        <!-- START SCREEN -->
        <div id="start-screen" class="screen">
            <h1 class="title">NEON PULSE</h1>
            <p class="subtitle neon-text" data-i18n="instructions">Tap screen or Spacebar to switch direction.<br>Avoid walls, collect crystals.</p>
            
            <div style="margin-bottom: 20px;">
                <span class="label" style="display:block; margin-bottom:10px;" data-i18n="selectMode">SELECT MODE</span>
                <div class="btn-group">
                    <button class="btn active" id="mode-classic" onclick="setMode('classic')" data-i18n="modeClassic">Classic</button>
                    <button class="btn btn-secondary" id="mode-zen" onclick="setMode('zen')" data-i18n="modeZen">Zen (No Die)</button>
                </div>
            </div>

            <button class="start-btn btn" id="startBtn" onclick="startGame()" style="font-size: 1.5rem; padding: 15px 50px; border-width: 3px;" data-i18n="start">START</button>
        </div>

        <!-- PAUSE SCREEN -->
        <div id="pause-screen" class="screen hidden">
            <h1 class="title" style="font-size: 3rem; color: #fff;">PAUSED</h1>
            <div class="btn-group" style="flex-direction: column;">
                <button class="btn" onclick="togglePause()" data-i18n="resume">Resume</button>
                <button class="btn btn-secondary" onclick="quitGame()" data-i18n="quit">Quit</button>
            </div>
        </div>

        <!-- GAME OVER SCREEN -->
        <div id="game-over-screen" class="screen hidden">
            <h1 class="title" style="color: var(--neon-red); text-shadow: 0 0 20px var(--neon-red);">GAME OVER</h1>
            <p class="subtitle" style="font-size: 1.5rem;">
                <span data-i18n="score">Score</span>: <span id="final-score" style="color:#fff; font-weight:bold;">0</span>
            </p>
            <p id="new-record-msg" class="hidden" style="color: var(--neon-yellow); font-weight: bold; margin-bottom: 20px;" data-i18n="newRecord">NEW RECORD!</p>
            
            <div class="btn-group">
                <button class="btn" onclick="startGame()" data-i18n="retry">Retry</button>
                <button class="btn btn-secondary" onclick="quitGame()" data-i18n="menu">Menu</button>
            </div>
        </div>
    </div>

    <script>
        // --- TRANSLATION SYSTEM ---
        const translations = {
            en: {
                score: "SCORE",
                best: "BEST",
                instructions: "Tap screen or Spacebar to switch direction.\nAvoid walls, collect crystals.",
                selectMode: "SELECT MODE",
                modeClassic: "CLASSIC",
                modeZen: "ZEN (NO DIE)",
                start: "START",
                resume: "RESUME",
                quit: "QUIT",
                retry: "RETRY",
                menu: "MENU",
                gameover: "GAME OVER",
                paused: "PAUSED",
                newRecord: "NEW RECORD!"
            },
            zh: {
                score: "ÂæóÂàÜ",
                best: "ÊúÄÈ´òÂàÜ",
                instructions: "ÁÇπÂáªÂ±èÂπïÊàñÁ©∫Ê†ºÈîÆÂàáÊç¢ÊñπÂêë„ÄÇ\nÈÅøÂºÄÂ¢ôÂ£ÅÔºåÊî∂ÈõÜÊ∞¥Êô∂„ÄÇ",
                selectMode: "ÈÄâÊã©Ê®°Âºè",
                modeClassic: "ÁªèÂÖ∏Ê®°Âºè",
                modeZen: "Á¶ÖÊ®°Âºè (‰∏çÊ≠ª)",
                start: "ÂºÄÂßãÊ∏∏Êàè",
                resume: "ÁªßÁª≠Ê∏∏Êàè",
                quit: "ÈÄÄÂá∫",
                retry: "ÈáçËØï",
                menu: "‰∏ªËèúÂçï",
                gameover: "Ê∏∏ÊàèÁªìÊùü",
                paused: "ÊöÇÂÅú",
                newRecord: "Êñ∞Á∫™ÂΩïÔºÅ"
            },
            ja: {
                score: "„Çπ„Ç≥„Ç¢",
                best: "„Éô„Çπ„Éà",
                instructions: "ÁîªÈù¢„Çø„ÉÉ„Éó„Åæ„Åü„ÅØ„Çπ„Éö„Éº„Çπ„Ç≠„Éº„ÅßÊñπÂêëËª¢Êèõ„ÄÇ\nÂ£Å„ÇíÈÅø„Åë„ÄÅ„ÇØ„É™„Çπ„Çø„É´„ÇíÈõÜ„ÇÅ„Çà„ÅÜ„ÄÇ",
                selectMode: "„É¢„Éº„ÉâÈÅ∏Êäû",
                modeClassic: "„ÇØ„É©„Ç∑„ÉÉ„ÇØ",
                modeZen: "Á¶Ö (ÁÑ°Êïµ)",
                start: "„Çπ„Çø„Éº„Éà",
                resume: "ÂÜçÈñã",
                quit: "ÁµÇ‰∫Ü",
                retry: "„É™„Éà„É©„Ç§",
                menu: "„É°„Éã„É•„Éº",
                gameover: "„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº",
                paused: "‰∏ÄÊôÇÂÅúÊ≠¢",
                newRecord: "Êñ∞Ë®òÈå≤ÔºÅ"
            },
            es: {
                score: "PUNTOS",
                best: "MEJOR",
                instructions: "Toca o usa Espacio para cambiar direcci√≥n.\nEvita las paredes, recoge cristales.",
                selectMode: "MODO",
                modeClassic: "CL√ÅSICO",
                modeZen: "ZEN (INVENCIBLE)",
                start: "JUGAR",
                resume: "CONTINUAR",
                quit: "SALIR",
                retry: "REINTENTAR",
                menu: "MEN√ö",
                gameover: "FIN DEL JUEGO",
                paused: "PAUSA",
                newRecord: "¬°NUEVO R√âCORD!"
            },
            fr: {
                score: "SCORE",
                best: "MEILLEUR",
                instructions: "Tapez ou Espace pour changer de direction.\n√âvitez les murs, collectez les cristaux.",
                selectMode: "MODE",
                modeClassic: "CLASSIQUE",
                modeZen: "ZEN (INVINCIBLE)",
                start: "D√âMARRER",
                resume: "REPRENDRE",
                quit: "QUITTER",
                retry: "R√âESSAYER",
                menu: "MENU",
                gameover: "PERDU",
                paused: "PAUSE",
                newRecord: "NOUVEAU RECORD!"
            }
        };

        let currentLang = 'en';

        function changeLanguage(lang) {
            currentLang = lang;
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (translations[lang][key]) {
                    el.innerText = translations[lang][key];
                }
            });
            // Update mode buttons state text specifically
            document.getElementById('mode-classic').innerText = translations[lang]['modeClassic'];
            document.getElementById('mode-zen').innerText = translations[lang]['modeZen'];
        }

        // --- GAME ENGINE ---

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        // Settings & State
        let gameState = 'MENU'; // MENU, PLAYING, PAUSED, GAMEOVER
        let gameMode = 'classic'; // 'classic' or 'zen'
        let animationId;
        let score = 0;
        let highScore = 0;
        let speed = 0;
        let frameCount = 0;
        let isMuted = false;
        let shake = 0; // Screen shake intensity

        // Constants
        const COLORS = {
            bg: '#050505',
            wall: '#39ff14', 
            player: '#ff0055',
            obstacle: '#ff3333',
            coin: '#00ffff'
        };

        const WALL_WIDTH = 40;
        const GAP_HEIGHT = 260;
        const WALL_BUFFER = 25;

        // Entities
        const player = {
            x: 0, y: 0, radius: 8,
            dy: 0, speedX: 0, baseSpeed: 7,
            trail: [], angle: 0
        };

        let cameraX = 0;
        let walls = [];
        let obstacles = [];
        let coins = [];
        let particles = [];

        // Save System
        function loadData() {
            const saved = localStorage.getItem('neon_pulse_save');
            if (saved) {
                const data = JSON.parse(saved);
                highScore = data.highScore || 0;
                // We can extend this to save coins/money later
            }
            document.getElementById('highscore-display').innerText = highScore;
        }

        function saveData() {
            localStorage.setItem('neon_pulse_save', JSON.stringify({
                highScore: Math.max(score, highScore)
            }));
            if (score > highScore) {
                highScore = score;
                document.getElementById('highscore-display').innerText = highScore;
            }
        }

        // --- GAMEPLAY LOGIC ---

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (gameState === 'MENU') drawMenuBackground();
            else if (gameState === 'PAUSED') draw(); // Redraw static if paused
        }
        window.addEventListener('resize', resize);

        function setMode(mode) {
            gameMode = mode;
            // UI Toggle logic
            document.getElementById('mode-classic').classList.toggle('active', mode === 'classic');
            document.getElementById('mode-classic').classList.remove('btn-secondary');
            
            document.getElementById('mode-zen').classList.toggle('active', mode === 'zen');
            
            // Visual feedback on button types
            if (mode === 'classic') {
                document.getElementById('mode-classic').classList.add('active');
                document.getElementById('mode-zen').classList.remove('active');
            } else {
                document.getElementById('mode-classic').classList.remove('active');
                document.getElementById('mode-zen').classList.add('active');
            }
            playSound('ui');
        }

        function startGame() {
            score = 0;
            speed = player.baseSpeed;
            cameraX = 0;
            
            player.x = 200;
            player.y = canvas.height / 2;
            player.dy = -speed;
            player.speedX = speed;
            player.trail = [];

            walls = [];
            obstacles = [];
            coins = [];
            particles = [];
            
            // Generate Initial Safe Zone
            let startY = canvas.height / 2;
            lastWallY = startY;
            trend = 0;
            
            for (let i = 0; i < window.innerWidth / WALL_WIDTH + 10; i++) {
                generateWall(i * WALL_WIDTH, startY, true);
            }

            // UI
            document.querySelectorAll('.screen').forEach(el => el.classList.add('hidden'));
            document.getElementById('score-display').innerText = '0';
            document.getElementById('pause-btn').innerHTML = '‚è∏';
            
            gameState = 'PLAYING';
            playSound('start');
            startBgLoop();
            
            if (animationId) cancelAnimationFrame(animationId);
            lastTime = performance.now();
            loop();
        }

        function quitGame() {
            gameState = 'MENU';
            document.querySelectorAll('.screen').forEach(el => el.classList.add('hidden'));
            document.getElementById('start-screen').classList.remove('hidden');
            stopBgLoop();
            drawMenuBackground();
        }

        function togglePause() {
            if (gameState === 'PLAYING') {
                gameState = 'PAUSED';
                document.getElementById('pause-screen').classList.remove('hidden');
                document.getElementById('pause-btn').innerHTML = '‚ñ∂';
                stopBgLoop();
            } else if (gameState === 'PAUSED') {
                gameState = 'PLAYING';
                document.getElementById('pause-screen').classList.add('hidden');
                document.getElementById('pause-btn').innerHTML = '‚è∏';
                lastTime = performance.now(); // Prevent time jump
                startBgLoop();
                loop();
            }
        }

        // --- GENERATION ALGORITHMS ---

        let lastWallY = 0;
        let trend = 0;

        function generateWall(x, startY, isSafe) {
            // Smoother generation
            if (frameCount % 15 === 0) {
                trend += (Math.random() - 0.5) * 30;
                // Clamp trend so it doesn't get too steep
                trend = Math.max(-40, Math.min(40, trend));
            }

            let nextY = lastWallY + trend;
            const margin = 100;
            
            // Boundary checks with bounce
            if (nextY < margin + GAP_HEIGHT/2) {
                nextY = margin + GAP_HEIGHT/2 + 10;
                trend = Math.abs(trend) * 0.5;
            }
            if (nextY > canvas.height - margin - GAP_HEIGHT/2) {
                nextY = canvas.height - margin - GAP_HEIGHT/2 - 10;
                trend = -Math.abs(trend) * 0.5;
            }

            lastWallY = nextY;

            const topY = nextY - GAP_HEIGHT / 2;
            const bottomY = nextY + GAP_HEIGHT / 2;

            walls.push({ x: x, y: topY, by: bottomY, width: WALL_WIDTH, scored: false });

            if (!isSafe) {
                // Obstacles
                if (Math.random() < 0.2) {
                    const type = Math.random() > 0.5 ? 'top' : 'bottom';
                    obstacles.push({
                        x: x + WALL_WIDTH/2,
                        y: type === 'top' ? topY : bottomY,
                        type: type
                    });
                }
                
                // Coins (Crystals) - Placed in the middle
                if (Math.random() < 0.15) {
                    coins.push({
                        x: x + WALL_WIDTH/2,
                        y: nextY + (Math.random() - 0.5) * 100, // Slight variation
                        active: true
                    });
                }
            }
        }

        function switchDirection() {
            if (gameState !== 'PLAYING') return;
            player.dy = -player.dy;
            createExplosion(player.x, player.y, 5, player.dy > 0 ? '#ff0055' : '#ff55aa', 2);
            playSound('switch');
        }

        // --- INPUT ---

        function handleInput(e) {
            if (gameState === 'MENU' && e.type === 'keydown' && e.code === 'Enter') {
                startGame();
                return;
            }
            
            // Pause Toggle
            if (e.type === 'keydown' && (e.code === 'Escape' || e.code === 'KeyP')) {
                togglePause();
                return;
            }

            if (gameState !== 'PLAYING') return;

            if (e.type === 'keydown') {
                if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'ArrowDown') {
                    switchDirection();
                }
            } else if (e.type === 'touchstart' || e.type === 'mousedown') {
                // Ignore touches on UI buttons
                if (e.target.closest('button') || e.target.closest('select')) return;
                switchDirection();
                e.preventDefault();
            }
        }

        window.addEventListener('keydown', handleInput);
        canvas.addEventListener('mousedown', handleInput);
        canvas.addEventListener('touchstart', handleInput, {passive: false});

        // --- PHYSICS & UPDATES ---

        function update(dt) {
            // Speed progression
            // Cap speed slightly to prevent physics breaking at extreme scores (e.g. 100k+)
            const speedMultiplier = Math.min(3.5, 1 + (score * 0.0015));
            const currentSpeed = player.speedX * speedMultiplier;

            player.x += currentSpeed;
            player.y += player.dy * speedMultiplier;
            
            // Smooth Camera
            const targetCamX = player.x - canvas.width * 0.25;
            cameraX += (targetCamX - cameraX) * 0.1; 

            // Trail
            if (frameCount % 2 === 0) {
                player.trail.push({x: player.x, y: player.y});
                if (player.trail.length > 25) player.trail.shift();
            }

            // Generation
            // FIX: Use 'while' loop instead of 'if' to handle high speeds
            // Ensure we generate enough walls even if speed > wall_width per frame
            let lastWall = walls[walls.length - 1];
            while (lastWall.x < cameraX + canvas.width + WALL_BUFFER + 100) {
                generateWall(lastWall.x + WALL_WIDTH, 0, false);
                lastWall = walls[walls.length - 1];
            }

            // Cleanup
            if (walls[0].x + WALL_WIDTH < cameraX - 100) walls.shift();
            if (obstacles.length > 0 && obstacles[0].x < cameraX - 100) obstacles.shift();
            if (coins.length > 0 && coins[0].x < cameraX - 100) coins.shift();

            // Collisions
            checkCollisions();
            
            // Particles
            particles.forEach((p, index) => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= p.decay;
                if (p.life <= 0) particles.splice(index, 1);
            });

            // Score logic
            walls.forEach(w => {
                if (!w.scored && player.x > w.x + w.width) {
                    if (gameMode === 'classic') score++;
                    else score += 1; // Zen mode also scores but doesn't save highscore
                    
                    w.scored = true;
                    document.getElementById('score-display').innerText = score;
                }
            });

            // Screen Shake decay
            if (shake > 0) shake *= 0.9;
            if (shake < 0.5) shake = 0;

            frameCount++;
        }

        function checkCollisions() {
            // Walls
            const currentWall = walls.find(w => player.x >= w.x && player.x < w.x + w.width);
            let hitWall = false;
            let hitObstacle = false;

            if (currentWall) {
                // Use radius for collision margin
                const margin = player.radius; 
                
                // Top Wall Hit
                if (player.y - margin < currentWall.y) {
                    hitWall = true;
                    if (gameMode === 'zen') {
                        // Hard correction: Force player inside + Bounce
                        player.y = currentWall.y + margin + 2; 
                        if (player.dy < 0) player.dy = Math.abs(player.dy); // Force down
                    }
                } 
                // Bottom Wall Hit
                else if (player.y + margin > currentWall.by) {
                    hitWall = true;
                    if (gameMode === 'zen') {
                        // Hard correction: Force player inside + Bounce
                        player.y = currentWall.by - margin - 2;
                        if (player.dy > 0) player.dy = -Math.abs(player.dy); // Force up
                    }
                }
            } else {
                // Out of bounds (rare case fallback)
                if (player.y < 0 || player.y > canvas.height) {
                    hitWall = true;
                    if (gameMode === 'zen') {
                        player.y = canvas.height / 2; // Reset to center if somehow totally lost
                    }
                }
            }

            // Obstacles
            // In Zen mode, obstacles just cause penalty, they don't act as solid walls usually
            // but we still flag them
            if (!hitWall) {
                for (let obs of obstacles) {
                    const dist = Math.hypot(player.x - obs.x, player.y - obs.y);
                    if (dist < player.radius + 15) {
                        hitObstacle = true;
                        break;
                    }
                }
            }

            // Coins
            for (let c of coins) {
                if (c.active) {
                    const dist = Math.hypot(player.x - c.x, player.y - c.y);
                    if (dist < player.radius + 20) { // Generous hitbox for coins
                        c.active = false;
                        score += 10;
                        document.getElementById('score-display').innerText = score;
                        playSound('coin');
                        createExplosion(c.x, c.y, 10, COLORS.coin, 3);
                    }
                }
            }

            if (hitWall || hitObstacle) {
                if (gameMode === 'classic') {
                    gameOver();
                } else {
                    // Zen Mode: Penalize score, effects, but don't stop
                    if (frameCount % 10 === 0) { // Prevent spamming sounds every frame
                        playSound('hit');
                        shake = 10;
                        createExplosion(player.x, player.y, 5, '#fff', 5);
                        score = Math.max(0, score - 5);
                        document.getElementById('score-display').innerText = score;
                    }
                }
            }
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            stopBgLoop();
            playSound('crash');
            shake = 20;
            createExplosion(player.x, player.y, 60, '#fff', 8);
            
            // Check Highscore
            const isNewRecord = score > highScore;
            if (gameMode === 'classic') {
                saveData();
            }

            setTimeout(() => {
                document.getElementById('game-over-screen').classList.remove('hidden');
                document.getElementById('final-score').innerText = score;
                document.getElementById('new-record-msg').classList.toggle('hidden', !isNewRecord);
            }, 800);
        }

        // --- RENDERING ---

        function draw() {
            // Screen Shake Transform
            let tx = (Math.random() - 0.5) * shake;
            let ty = (Math.random() - 0.5) * shake;

            // Background
            ctx.fillStyle = COLORS.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid Effect (Moving background)
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 1;
            ctx.beginPath();
            const gridSize = 100;
            const offsetX = cameraX % gridSize;
            for (let x = -offsetX; x < canvas.width; x += gridSize) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            ctx.stroke();

            ctx.save();
            ctx.translate(-cameraX + tx, ty);

            // Walls (Glowy)
            ctx.shadowBlur = 15;
            ctx.shadowColor = COLORS.wall;
            ctx.strokeStyle = COLORS.wall;
            ctx.lineWidth = 4;
            
            // Draw Top Line
            ctx.beginPath();
            ctx.moveTo(walls[0].x, walls[0].y);
            for (let i = 1; i < walls.length; i++) ctx.lineTo(walls[i].x, walls[i].y);
            ctx.stroke();

            // Draw Bottom Line
            ctx.beginPath();
            ctx.moveTo(walls[0].x, walls[0].by);
            for (let i = 1; i < walls.length; i++) ctx.lineTo(walls[i].x, walls[i].by);
            ctx.stroke();
            
            // Reset Shadow for filling
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(57, 255, 20, 0.08)';
            
            // Fill Top (Dynamic height for safety)
            ctx.beginPath();
            ctx.moveTo(walls[0].x, walls[0].y);
            for (let w of walls) ctx.lineTo(w.x, w.y);
            ctx.lineTo(walls[walls.length-1].x, -2000); 
            ctx.lineTo(walls[0].x, -2000);
            ctx.fill();

            // Fill Bottom (Dynamic height for safety)
            ctx.beginPath();
            ctx.moveTo(walls[0].x, walls[0].by);
            for (let w of walls) ctx.lineTo(w.x, w.by);
            ctx.lineTo(walls[walls.length-1].x, canvas.height + 2000); 
            ctx.lineTo(walls[0].x, canvas.height + 2000);
            ctx.fill();

            // Obstacles
            ctx.lineWidth = 3;
            ctx.strokeStyle = COLORS.obstacle;
            ctx.fillStyle = '#000';
            ctx.shadowBlur = 10;
            ctx.shadowColor = COLORS.obstacle;
            
            obstacles.forEach(obs => {
                if (obs.x > cameraX - 50 && obs.x < cameraX + canvas.width + 50) {
                    ctx.beginPath();
                    const size = 18;
                    if (obs.type === 'top') {
                        ctx.moveTo(obs.x - size, obs.y);
                        ctx.lineTo(obs.x + size, obs.y);
                        ctx.lineTo(obs.x, obs.y + size * 1.5);
                    } else {
                        ctx.moveTo(obs.x - size, obs.y);
                        ctx.lineTo(obs.x + size, obs.y);
                        ctx.lineTo(obs.x, obs.y - size * 1.5);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
            });

            // Coins (Diamonds)
            ctx.shadowColor = COLORS.coin;
            ctx.fillStyle = COLORS.coin;
            coins.forEach(c => {
                if (c.active && c.x > cameraX - 50 && c.x < cameraX + canvas.width + 50) {
                    ctx.beginPath();
                    // Rotating effect
                    const size = 12 + Math.sin(frameCount * 0.1) * 2;
                    ctx.moveTo(c.x, c.y - size);
                    ctx.lineTo(c.x + size, c.y);
                    ctx.lineTo(c.x, c.y + size);
                    ctx.lineTo(c.x - size, c.y);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Sparkle
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(c.x - 2, c.y - 2, 4, 4);
                    ctx.fillStyle = COLORS.coin;
                }
            });

            // Player Trail
            if (player.trail.length > 1) {
                ctx.strokeStyle = COLORS.player;
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.shadowColor = COLORS.player;
                ctx.shadowBlur = 20;
                
                ctx.beginPath();
                ctx.moveTo(player.trail[0].x, player.trail[0].y);
                for (let i = 1; i < player.trail.length; i++) {
                    ctx.lineTo(player.trail[i].x, player.trail[i].y);
                }
                ctx.stroke();
            }

            // Player Head (Arrow)
            ctx.save();
            ctx.translate(player.x, player.y);
            const rotAngle = player.dy > 0 ? Math.PI / 4 : -Math.PI / 4;
            ctx.rotate(rotAngle);
            
            ctx.fillStyle = COLORS.player;
            ctx.shadowBlur = 25;
            ctx.shadowColor = COLORS.player;
            
            ctx.beginPath();
            ctx.moveTo(12, 0);
            ctx.lineTo(-10, 10);
            ctx.lineTo(-6, 0);
            ctx.lineTo(-10, -10);
            ctx.closePath();
            ctx.fill();
            
            // Core
            ctx.fillStyle = "#fff";
            ctx.shadowBlur = 5;
            ctx.beginPath();
            ctx.arc(-2, 0, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Particles
            ctx.shadowBlur = 10;
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            ctx.restore();
        }

        function drawMenuBackground() {
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Decorative Lines
            ctx.strokeStyle = 'rgba(57, 255, 20, 0.1)';
            ctx.lineWidth = 2;
            
            const time = Date.now() * 0.001;
            
            ctx.beginPath();
            for (let i = 0; i < canvas.width; i+=10) {
                const y = canvas.height/2 + Math.sin(i * 0.01 + time) * 100;
                if (i===0) ctx.moveTo(i, y);
                else ctx.lineTo(i, y);
            }
            ctx.stroke();
        }

        function createExplosion(x, y, count, color, speedMulti = 1) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10 * speedMulti,
                    vy: (Math.random() - 0.5) * 10 * speedMulti,
                    life: 1.0,
                    decay: 0.01 + Math.random() * 0.03,
                    size: Math.random() * 4 + 1,
                    color: color
                });
            }
        }

        // --- AUDIO SYSTEM ---

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let bgOsc1, bgOsc2, bgGain;

        function initAudio() {
            if (!audioCtx) audioCtx = new AudioContext();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        function toggleMute() {
            isMuted = !isMuted;
            document.getElementById('mute-btn').innerHTML = isMuted ? 'üîá' : 'üîä';
            if (isMuted) {
                stopBgLoop();
            } else if (gameState === 'PLAYING') {
                startBgLoop();
            }
        }

        function startBgLoop() {
            if (isMuted || !audioCtx) return;
            if (bgOsc1) return; // Already playing

            initAudio();
            const now = audioCtx.currentTime;

            // Drone/Engine sound
            bgOsc1 = audioCtx.createOscillator();
            bgOsc1.type = 'sawtooth';
            bgOsc1.frequency.value = 50; 
            
            // Pulsing effect
            bgOsc2 = audioCtx.createOscillator();
            bgOsc2.type = 'sine';
            bgOsc2.frequency.value = 2; // 2Hz Pulse
            
            bgGain = audioCtx.createGain();
            bgGain.gain.value = 0.03;

            // FM Synthesis kinda
            bgOsc1.connect(bgGain);
            bgGain.connect(audioCtx.destination);
            
            bgOsc1.start();
            bgOsc2.start();
        }

        function stopBgLoop() {
            if (bgOsc1) {
                try {
                    bgOsc1.stop();
                    bgOsc2.stop();
                } catch(e) {}
                bgOsc1 = null;
                bgOsc2 = null;
            }
        }

        function playSound(type) {
            if (isMuted) return;
            initAudio();
            
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;

            if (type === 'switch') {
                // High tech zip
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'coin') {
                // High ping
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, now);
                osc.frequency.exponentialRampToValueAtTime(1800, now + 0.1);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'crash') {
                // Noise crash
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.4);
                gainNode.gain.setValueAtTime(0.4, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
            } else if (type === 'ui') {
                // UI Click
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                gainNode.gain.setValueAtTime(0.05, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
            }
        }

        // --- LOOP ---
        let lastTime = 0;
        function loop(timestamp) {
            if (gameState !== 'PLAYING') return;

            const dt = timestamp - lastTime;
            // Cap delta time to prevent physics explosions on lag
            if (dt < 60) {
                update(dt);
                draw();
            }
            
            lastTime = timestamp;
            animationId = requestAnimationFrame(loop);
        }

        // Init
        loadData();
        resize();
        // Set default language from browser if possible, else English
        const browserLang = navigator.language.slice(0, 2);
        if (translations[browserLang]) {
            document.getElementById('lang-select').value = browserLang;
            changeLanguage(browserLang);
        } else {
            changeLanguage('en');
        }

    </script>
</body>
</html>